;(function(define, window) {
define([], function() {
    var f = {};
;(function() {
    "use strict";

    // собираем информацию о браузере
    f.aboutBrow = function() {
        var brow = navigator.vendor === '' && typeof navigator.vendor === 'string' ? 'Firefox' : ( navigator.vendor ? navigator.vendor.split(' ')[0] : 'Internet Explorer' );
		var platform = navigator.platform;
		var screenW = screen.availWidth;
		var screenH = screen.availHeight;
		var vers = navigator.appVersion.toLowerCase();
		var fullData = '';

		if ( brow == "Google" && f.isObject(window.opr) ) {
			brow = "Opera";
		}

		if ( f.isFunction(window.msClearImmediate) ) {
			brow = "Internet Explorer";
			vers = "11.0";
		} else {
			try{
				vers = ({
					'opera' :function(){ return vers.split('opr/')[1]; },
					'firefox' :function(){ return vers.split(' ')[0]; },
					'internet explorer' :function(){ return vers.split('msie ')[1].split(';')[0]; },
					'apple' :function(){ return vers.split('version/')[1]; },
					'google' :function(){ return vers.split('chrome/')[1].split(' ')[0]; }
				})[brow.toLowerCase()]();
			} catch( e ) {
				brow = 'unknown';
				vers = 'unknow';
				fullData = '\n\r' + navigator.vendor + '; ' + navigator.platform + ';' + navigator.appVersion;
			}
		}


		var isIphone = platform.toLowerCase().indexOf('iphone') != -1 || navigator.userAgent.indexOf("iPhone") != -1,
			isPad = platform.toLowerCase().indexOf('iphone') != -1 || navigator.userAgent.indexOf("iPad") != -1,
			isArm = platform.toLowerCase().indexOf('arm') != -1 || navigator.userAgent.indexOf("Android") != -1,
			isMobile = isIphone || isPad || isArm
		;
		return {
			brow: brow,
			platform: platform,
			screenW: screenW,
			screenH: screenH,
			isIphone: isIphone,
			isPad: isPad,
			isArm: isArm,
			isMobile: isMobile,
			vers: vers,
			toString : function(){
				return "Browser: " + brow + ', Version: ' + vers + ', Platform: ' + platform + ', Screen: ' + screenW + ' X ' + screenH + fullData;
			}
		};
	};

})();

;(function() {
    "use strict";

	// http://javascript.ru/ajax/intro
	f.getXHR = function() {
		var xmlhttp;
		try {
			xmlhttp = new ActiveXObject("Msxml2.XMLHTTP");
		} catch (e) {
			try {
				xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
			} catch (E) {
				xmlhttp = false;
			}
		}
		if (!xmlhttp && typeof XMLHttpRequest!='undefined') {
			xmlhttp = new XMLHttpRequest();
		}
		return xmlhttp;
	};
    
    f.ajax = function() {
        return new Promise(function(resolve, reject) { // jshint ignore: line
            $.ajax(
                f.deepMixin(params, {
                    success: function(response) {
                        try {
                            response = JSON.parse(response);
                            resolve(response);
                        } catch(err) {
                            reject(err);
                        }
                    },
                    error: function(err) {
                        reject(err);
                    }
                })
            );
        });
    };
    
})();

;(function() {
    "use strict";
    // функции для работы с массивами
    
	//
	// !! \THROW/ WARNING !!
	// sorts: [{key: 1}, {KEY2: -1}]
	// default str sort
	f.multiSort = function(arr, sorts, comparatorByKey) {

		var keys = [], key;
		var vectors = {}, vector;

		sorts.forEach(function(row) {
			for (var key in row) {
				vector = row[key];

				if ( vector !== 1 && vector !== -1 ) {
					throw new Error("bad sort vector");
				}

				vectors[key] = vector;
				keys.push(key);
				break;
			}
		});

		//  сортировка по числу отличается от сортировки по строке
		var comparator_str = function(key, a, b) {
			return a[key] == b[key] ? 0 :
					a[key] > b[key] ? vectors[key] : -vectors[key];
		};

		var comparator_number = function(key, a, b) {
			return +a[key] == +b[key] ? 0 :
					+a[key] > +b[key] ? vectors[key] : -vectors[key];
		};

		var comparator_currency = function(key, a, b) {
			a = f.currencyToNumber(a[key]);
			b = f.currencyToNumber(b[key]);

			return +a == +b ? 0 :
					+a > +b ? vectors[key] : -vectors[key];
		};

		// пользовательские компораторы (сортировки по столбцу)
		if ( !comparatorByKey ) {
			comparatorByKey = {};
		} else {
			comparatorByKey = f.deepClone(comparatorByKey);
			for (key in comparatorByKey) {
				if ( f.isString(comparatorByKey[key]) ) {
					if ( comparatorByKey[key] == "number" ) {
						comparatorByKey[key] = comparator_number;
					} else
					if ( comparatorByKey[key] == "currency" ) {
						comparatorByKey[key] = comparator_currency;
					}
					if ( !f.isFunction(comparatorByKey[key]) ) {
						delete comparatorByKey[key];
					}
				}
			}
		}

		var n = keys.length;
		return arr.sort(function(a, b) {
			var res;
			for (var i=0; i<n; i++) {
				if ( comparatorByKey[keys[i]] ) {
					res = comparatorByKey[keys[i]](keys[i], a, b);
				} else {
					res = comparator_str(keys[i], a, b);
				}

				if ( res !== 0 ) {
					return res;
				}
			}
			return 0;
		});
	};
    
    f.multiSortModels = function(models, sorts, comparatorByKey) {
        // костыльно, зато эффективно
        var rows = models.map(function(model) {
            model.attributes.____model____ = model;
            return model.attributes;
        });
        
        rows = f.multiSort(rows, sorts, comparatorByKey);
        return rows.map(function(row) {
            var model = row.____model____;
            delete row.____model____;
            return model;
        });
    };

	// поиск индекса объекта, который содержит опередленный ключ
	f.objIndexOfByKey = function(objs, key) {
		for (var i=0, n=objs.length; i<n; i++) {
			if ( key in objs[i] ) {
				return i;
			}
		}
		return -1;
	};
    
    f.findObjects = function(source, check, path) {
        if ( !path ) {
            path = [];
        }
        var result = [];
        
        if ( f.isObject(source) ) {
            if ( check(source, path) ) {
                result.push(source);
            }
            for (var key in source) {
                result = result.concat( 
                        f.findObjects(
                            source[key], check, 
                            path.concat([["object", key, source]])
                        ) 
                    );
            }
        } else
        if ( f.isArray(source) ) {
            source.forEach(function(elem, i) {
                result = result.concat( 
                    f.findObjects(
                        elem, check,
                        path.concat([["array", i, source]])
                    ) 
                );
            });
        }
        
        return result;
    };
})();

;(function() {
	"use strict";
	
	// полседовательное выполнение асинхронных функций
	// в голом виде не рекомендуется использовать
	f.series = function(series, callback, context) {
		if ( !f.isFunction(callback) ) {
			callback = function() {};
		}

		series = f.deepClone(series);
		var results = [];
		var resultErr = null;
        
        if ( !context ) {
            context = this;
        }
        
		function iterate() {
			var func = series.shift();
			func.call(context, function(err, result) {
				results.push(result);

				if ( err || series.length === 0 ) {
					return stop(err);
				}

				iterate();
			});
		}

		function stop(err) {
			if ( err ) {
				resultErr = err;
			}

			callback.call(context, resultErr, results);
		}
        
        if ( series.length === 0 ) {
            setTimeout(callback.bind(context, null, []), 0);
        } else {
            iterate();
        }
        
	};

	f.parallel = function(funcs, callback, context) {
		if ( !f.isFunction(callback) ) {
			callback = function() {};
		}
        
        if ( !context ) {
            context = this;
        }
        
		var results = [];
		var resultErr = null;
		var count = funcs.length;
		var stoped = false;
		function iterate(func) {
			if ( stoped ) {
				return;
			}

			func.call(context, function(err, result) {
				if ( stoped ) {
					return;
				}

				results.push(result);

				if ( err || results.length >= count ) {
					return stop(err);
				}
			});
		}

		function stop(err) {
			stoped = true;
			if ( err ) {
				resultErr = err;
			}

			callback.call(context, resultErr, results);
		}

		funcs.forEach(iterate);
		if ( funcs.length === 0 ) {
			stop();
		}
	};

    f.waitProp = function(obj, propName, callback) {
        var wait = function() {
            if ( obj[propName] ) {
                callback(obj);
            } else {
                // потеряет стек:
                // setTimeout(wait, 5);
                
                // не потеряет стек:
                setTimeout(function() {
                    wait();
                }, 5);
            }
        };
        
        wait();
    };
	//
    // без отличного понимания JS код не изменять !
    //
    // любой метод работает БЕЗ потери стека вызовов!
    var Queue = function(context) {
        this.context = context;
        this._loading = {
            inProcess: 0,
            total: 0
        };
        
        // ignore
        this._lastIgnoredCall = false;
        // rotation
        this._rotationCount = 0;
        this._rotationCurrent = 1;
        // series
        this._seriesStack = [];
    };
    
    // описание любого метода:
    // 
    // run - асинхронная функция, которая выполняется неопределенное кол-во времени.
    // она будет запущена, когда дождется своей очереди или будет запущена сразу, а может быть проигнорированна 
    // (зависит от метода)
    // 
    // callback - обратный вызов для run, который будет выполнен, только когда
    //   дождется своей очереди
    //   
    // важно понимать, что они между собой связаны!
    
    
    
    // series вызывает series, после завершения предыдущего вызова series
    //  
    //  r1_________c1 
    //                r2__c2 
    //                       r3___c3
    Queue.prototype.series = function(run, callback) {
        if ( this._destroyed ) {
            return;
        }
        if ( !f.isFunction(callback) ) {
            callback = function() {};
        }
        
        var context = this.context;
        
        this._seriesStack.push({
            run: run,
            callback: function() {
                var args = [].slice.call(arguments);
                callback.apply(context, args);
            }.bind(this)
        });
        
        this._seriesNext();
    };
    
    Queue.prototype._seriesNext = function() {
        if ( this._destroyed ) {
            return;
        }
        
        var context = this.context,
            call = this._seriesStack[0];
        
        if ( call && !call.loading ) {
            call.loading = true;
            
            call.run.call(context, function() {
                this._seriesStack.shift();
                
                var args = [].slice.call(arguments);
                call.callback.apply(context, args);
                
                this._seriesNext();
            }.bind(this));
        }
    };
    
    // rotation вызывает run сразу как вызван rotation,
    // callback будут вызваны по очереди (первый run, первый callback)
    //  
    //  r1_______c1
    //    r2__     c2
    //      r3___    c3
    //    
    Queue.prototype.rotation = function(run, callback) {
        if ( this._destroyed ) {
            return;
        }
        if ( !f.isFunction(callback) ) {
            callback = function() {};
        }
        
        var number = ++this._rotationCount,
            args = [],
            context = this.context;
        
        var wait = function() {
            if ( this._destroyed ) {
                return;
            }
            
            if ( this._rotationCurrent == number ) {
                callback.apply(context, args);
                this._rotationCurrent++;
                
                this._loading.total++;
                
                var nextCall = this._lastIgnoredCall;
                if ( nextCall ) {
                    this._lastIgnoredCall = null;
                    
                    this.ignore(
                        nextCall.run, 
                        nextCall.callback
                    );
                }
            } else {
                // потеряет стек:
                // setTimeout(wait, 5);
                
                // не потеряет стек:
                setTimeout(function() {
                    wait();
                }, 5);
            }
        }.bind(this);
        
        this._loading.inProcess++;
        run.call(context, function() {
            args = [].slice.call(arguments);
            wait();
        });
    };
    
    // принцип игнорирования вызовов, во время ожидания ответа
    //  
    //  r1_________c1 |
    //   ignore r2    |
    //    ignore r3   |
    //                 r3_________c3
    //                   ignore...
    Queue.prototype.ignore = function(run, callback) {
        if ( this._destroyed ) {
            return;
        }
        
        if ( !f.isFunction(callback) ) {
            callback = function() {};
        }
        
        var call = {run: run, callback: callback};
        
        if ( this._loading.total < this._loading.inProcess ) {
            this._lastIgnoredCall = call;
            return;
        }
        this._loading.inProcess++;
        
        var context = this.context;
        run.call(context, function() {
            if ( this._destroyed ) {
                return;
            }
            
            this._loading.total++;
            
            var args = [].slice.call(arguments);
            callback.apply(context, args);
            
            var nextCall = this._lastIgnoredCall;
            if ( nextCall ) {
                this._lastIgnoredCall = null;
                
                this.ignore(
                    nextCall.run, 
                    nextCall.callback
                );
            }
        }.bind(this));
    };
    
    Queue.prototype.destroy = function() {
        this._destroyed = true;
        this._seriesStack = [];
    };
    f.queue = function(context) {
    
        return new Queue(context);
    };
    
    
    // ну и пример использования
    // 
    // SERIES
    /*
    var self = {};
    var queue = f.queue(self);


    queue.series(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r1");
    }, function() {
        console.log("c1");
    });


    queue.series(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r2");
    }, function() {
        console.log("c2");
    });

    queue.series(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r3");
    }, function() {
        console.log("c3");
    });
    
    //  r1
    //  c1
    //  r2
    //  c2
    //  r3
    //  c3
    */
    // ROTATION
    /*
    var self = {};
    var queue = f.queue(self);
 
 
    queue.rotation(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r1");
    }, function() {
        console.log("c1");
    });
 
 
    queue.rotation(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r2");
    }, function() {
        console.log("c2");
    });
 
    queue.rotation(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r3");
    }, function() {
        console.log("c3");
    });
    
    //  r1
    //  r2
    //  r3
    //  c1
    //  c2
    //  c3
    */
    // IGNORE
    /*
    var self = {};
    var queue = f.queue(self);
 
 
    queue.ignore(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r1");
    }, function() {
        console.log("c1");
    });
 
 
    queue.ignore(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r2");
    }, function() {
        console.log("c2");
    });
 
    queue.ignore(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r3");
    }, function() {
        console.log("c3");
    });
    
    //  r1
    //  c1
    //  r3
    //  c3
    */
    
   
})();

;(function() {
    "use strict";

    // результат - объект, разница между двумя исходными объектами
    // данные в результате будут взяты из объекта b
    // сравнение не строгое
    f.deepChangedData = function(a, b) {

        if ( !f.isObject(a) ) {
            a = {};
        }

        if ( !f.isObject(b) ) {
            b = {};
        }

        function diff(a, b) {
            var out = {};

            for (var key in b) {
                if ( !f.isObject(b[key]) ) {
                    if ( a[key] != b[key] ) {
                        out[key] = f.deepClone(b[key]);
                    }
                } else {
                    if ( f.isObject(a[key]) ) {
                        out[key] = diff(a[key], b[key]);
                        if ( JSON.stringify(out[key]) == "{}" ) {
                            delete out[key];
                        }
                    } else {
                        out[key] = f.deepClone(b[key]);
                    }
                }
            }

            return out;
        }

        return diff(a, b);
    };

})();

;(function() {
    "use strict";
    
    // глубокое клонирование объекта,
    // !!! объекты созданые конструктором, передаются по ссылке
	f.deepClone = function(obj) {

		function cloneValue(value) {
			var out = value,
					arr;

			if ( f.isEasyObject(value) ) {
				out = f.deepClone(value);
			} else
			if ( f.isArray(value) ) {
				arr = [];
				for (var i=0, n=value.length; i<n; i++) {
					arr[i] = cloneValue(value[i]);
				}
				out = arr;
			}

			return out;
		}

		var clone, value;
		if ( f.isObject(obj) ) {
			clone = {};
			for (var key in obj) {
				clone[key] = cloneValue( obj[key] );
			}
		} else {
			clone = cloneValue(obj);
		}

		return clone;
	};

})();

;(function() {
    "use strict";

    // функции для работы с датами

	f.getLastDayOfMonth = function(year, month) {
	  var date = new Date(+year, +month + 1, 0);
	  return date.getDate();
  	};

	f.minutesToTimeFormat = function(minutes, roundTo) {
		roundTo = roundTo || 1;
		minutes = Math.max(0, minutes);

		var hours = Math.floor( minutes / 60 );

		minutes = minutes % 60;
		// округляем до 0 15 30 45 60 (если roundTo = 15)
		minutes = roundTo * Math.round( minutes * ( 1 / roundTo ) );
		if ( minutes > 59 ) {
			hours++;
			minutes = 0;
		}

		hours = Math.min(hours, 23);

		if ( hours < 10 ) {
			hours = "0" + hours;
		}

		if ( minutes < 10 ) {
			minutes = "0" + minutes;
		}

		return hours + ":" + minutes;
	};

	f.timeFormatToMinutes = function(time) {
		return 60 * time.split(":")[0] + 1 * time.split(":")[1];
	};



	// на ВХОДЕ может быть:
	// unixTimestamp,
	// timestamp,
	// объект Date,
	// то что может распарсить f.parseDate (dd.mm.yyyy hh:mm:ss и подобное),
	// то что может распарсить Date.parse
	// на ВЫХОДЕ
	// unixTimestamp или
	// NaN - если не удалось распарсить время
	f.clientTime2serverTime = function(clientTime) {
		var timestamp;

		timestamp = +f.parseDate(clientTime+"").date;
		if ( f.isNaN(timestamp) ) {
			timestamp = Date.parse(clientTime);
		}

		return f.unixTimestamp2serverTime(timestamp);
	};

    f.parseDate = function(str) {
		var defFormat = 'd.m.Y H:i';

		var date, format,
			year, month, day, hours, minutes, seconds, ms;

		if ( f.isNumber(+str) ) {
			date = new Date(+str);
			format = defFormat;
		} else
		if ( f.isDate(str) ) {
			date = str;
			format = defFormat;
		} else
		if ( f.isString(str) ) {
			str = str.trim();

			// сначало проверяем на формат ISO
			// 2015-08-31T21:00:00.000Z
			if ( /^\d\d\d\d\-\d\d\-\d\dT\d\d\:\d\d\:\d\d/.test(str) ) {
				return {
					format: "YYYY-MM-DDTHH:mm:ss.sssZ",
					date: new Date(Date.parse(str))
				};
			}
			// дописываем неполные даты

			// указан только год
			if ( /^\d\d\d\d$/.test(str) ) {
				str = "01." + str;
			}

			// указан месяц без нуля и год
			if ( /^\d.\d\d\d\d$/.test(str) ) {
				str = "01.0" + str;
			}
			// указан месяц с нулем и год
			if ( /^\d\d.\d\d\d\d$/.test(str) ) {
				str = "01." + str;
			}

			// день указан без нуля, месяц с нулем или без, год
			if ( /^\d.(\d\d|\d).\d\d\d\d$/.test(str) ) {
				str = "0" + str;
			}
			// день, месяц без нуля, год
			if ( /^\d\d.\d.\d\d\d\d$/.test(str) ) {
				str = str.slice(0, 3) + "0" + str.slice(3);
			}

			// разделители могут абсолютно любые
			// day.month.year hours:minutes:seconds:ms
			// 26.06.2015 12:03:48:123
			// year.month.day hours:minutes:seconds:ms
			// 2015.06.26 12:03:48:123
			if ( /^(\d\d.\d\d.\d\d\d\d|\d\d\d\d.\d\d.\d\d)(.\d\d.\d\d(.\d\d(.\d\d\d)?)?)?/.test(str) ) {

				if ( /^\d\d\d\d/.test(str) ) {
					day = str.slice(8, 10);
					month = str.slice(5, 7)-1;
					year = str.slice(0, 4);
					format = [
							"Y",
							str.slice(4, 5),
							"m",
							str.slice(7, 8),
							"d"
						].join('');
				} else {
					day = str.slice(0, 2);
					month = str.slice(3, 5)-1;
					year = str.slice(6, 10);
					format = [
							"d",
							str.slice(2, 3),
							"m",
							str.slice(5, 6),
							"Y"
						].join('');
				}

				if ( str.length > 10 ) {
					hours = str.slice(11, 13);
					minutes = str.slice(14, 16);

					format += [
						str.slice(10, 11),
						"H",
						str.slice(13, 14),
						"i"
					].join('');

					if ( str.length > 16 ) {
						seconds = str.slice(17, 19);
						format += [
							str.slice(16, 17),
							"s"
						].join('');

						/*
						if ( str.length > 19 ) {
							ms = str.slice(20, 23);
								format += [
								str.slice(19, 20),
								"xxx"
							].join('');
							date = new Date(year, month, day, hours, minutes, seconds, ms);
						} else {
						*/
							date = new Date(year, month, day, hours, minutes, seconds);
						//}
					} else {
						date = new Date(year, month, day, hours, minutes);
					}
				} else {
					date = new Date(year, month, day);
				}
			} else {
				date = new Date(str);
				format = defFormat;
				// unknown date
			}
		} else {
			date = new Date();
			format = defFormat;
		}

		return {date: date, format: format};
	};

	f.unixTimestamp2serverTime = function(unixTimestamp) {
		if ( f.isNaN(+unixTimestamp) ) {
			return +unixTimestamp;
		}
        
	    return new Date(unixTimestamp).toISOString(); // 2016-05-19 03:00 UTC+3 превращается в 2016-05-19 00:00 UTC
	};

	f.serverTime2timestamp = function(isoString) {
		return Date.parse(isoString);
	};

	// любая дата в dd.mm.yy
	f.serverTime2clientUserDate = function(date) {
		date = f.parseDate(date).date;
		date = f.timestamp2userdate(date);
		return date.split(" ")[0];
	};

	f.timestamp2userdate = function(timestamp) {
        var date = new Date(timestamp);
        var month = date.getMonth() + 1;

		// дата некорректна
        if ( month + "" == "NaN" ) {
            return "";
        }

		var hours = date.getHours();
		var minutes = date.getMinutes();

        if ( month < 10 ) {
            month = "0" + month;
        }
		if ( hours < 10 ) {
			hours = "0" + hours;
		}
		if ( minutes < 10 ) {
			minutes = "0" + minutes;
		}

		var day = date.getDate();
		if ( day < 10 ) {
			day = "0" + day;
		}

        return day + "." + month + "." + date.getFullYear() + " " + hours + ":" + minutes;
    };
    
    // если сегодня, то время: 11:07
    // если на неделе, то день недели: Вт
    // если раньше, то дата:  10.08.14
    f.printTimeOrDate = function(date) {
        date = f.parseDate(date).date;
        var now = new Date(),
            morning = new Date(+now),
            minutes, day, hours, month;
        
        morning.setHours(0);
        morning.setMinutes(0);
        
        // сегодня    
        if ( date > morning ) {
            minutes = date.getMinutes();
            if ( minutes < 10 ) {
                minutes = "0" + minutes;
            }
            return date.getHours() + ":" + minutes;
        }
        
        // вчера
        if ( date > morning - 24 * 60 * 60 * 1000 ) {
            return "Вчера";
        }
        
        // в России неделя начинается с понедельника
        day = date.getDay();
        if ( day === 0 ) {
            day = 7;
        }
        day--;
        
        // начало недели
        if ( date > morning - day * 24 * 60 * 60 * 1000 ) {
            return ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"][day];
        }
        
        // когда-то...
        month = date.getMonth() + 1;

        if ( month < 10 ) {
            month = "0" + month;
        }

        return date.getDate() + "." + month + "." + (date.getFullYear()+"").slice(2);
    };
    
    // если сегодня, то время: 11:07
    // если на неделе, то день недели: Вт, 11:07
    // если раньше, то дата:  10.08.14, 11:07
    f.printTimeOrDateWithTime = function(date) {
        date = f.parseDate(date).date;
        var now = new Date(),
            morning = new Date(+now),
            minutes = date.getMinutes(), 
            day, hours, month,
            timePart;
        
        if ( minutes < 10 ) {
            minutes = "0" + minutes;
        }
        timePart = date.getHours() + ":" + minutes;
        
        morning.setHours(0);
        morning.setMinutes(0);
        
        // сегодня    
        if ( date > morning ) {
            return timePart;
        }
        
        // вчера
        if ( date > morning - 24 * 60 * 60 * 1000 ) {
            return "Вчера, " + timePart;
        }
        
        // в России неделя начинается с понедельника
        day = date.getDay();
        if ( day === 0 ) {
            day = 7;
        }
        day--;
        
        // начало недели
        if ( date > morning - day * 24 * 60 * 60 * 1000 ) {
            return ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"][day] + ", " + timePart;
        }
        
        // когда-то...
        month = date.getMonth() + 1;

        if ( month < 10 ) {
            month = "0" + month;
        }

        return date.getDate() + "." + month + "." + (date.getFullYear()+"").slice(2) + ", " + timePart;
    };
    
})();

;(function() {
    "use strict";
    // функции для работы с DOM

    // получаем scroll документа
    function getScroll() {
	  var   x = 0,
			y = 0,
			html = document.getElementsByTagName('html')[0],
			body = document.body;

		if ( window.pageXOffset != undefined ) {
			y = pageYOffset;
			x = pageXOffset;
		} else {
			y = (html.scrollTop||body&&body.scrollTop||0) - html.clientTop;
			x = (html.scrollLeft||body&&body.scrollLeft||0) - html.clientLeft;
		}

		return {
				top : y,
				left : x
			};
	}
	f.getScroll = getScroll;

    // на входе может быть строка, dom-element, jquery-объект
	// иначе ошибка
	// на выходе jquery-объект
	f.checkElem = function($el) {
		if ( f.isString($el) || $el instanceof Element ) {
			$el = $($el);
		} else
		if ( !($el instanceof $) ) {
			throw new Error("bad elem", $el);
		}
		return $el;
	};

    // проверяем находится ли $el внутри $wrapper
	f.checkElemIn = function($el, $wrapper) {
        $el = f.checkElem($el);
        $wrapper = f.checkElem($wrapper);
        var el = $el.get(0);
        var wrapper = $wrapper.get(0);

        if ( wrapper == el ) {
            return true;
        }

        var body = document.body;
        if ( wrapper != body && el == body ) {
            return false;
        }

        var parent = el.parentNode;
        while ( parent && parent != body && parent != wrapper  ) {
            parent = parent.parentNode;
        }

        return parent == wrapper;
    };

    // определяем размеры окна
    function gwh(doc){
		doc = doc || document;
		var elem  = doc.compatMode == 'CSS1Compat' ? doc.documentElement : doc.body;
		return [elem.clientWidth, elem.clientHeight];
	}

	f.getWindowSize = function() {
		var wh = gwh();
		return {
			width: wh[0],
			height: wh[1]
		};
	};

    // удобный метод для "классов", который находит $box в параметрах
    f.initBox = function(params) {
		if ( !f.isObject(params) ) {
			params = {};
		}

		var $box, box;
		// { box: "selector" }
		if ( f.isString(params.box) ) {
			$box = $(params.box);
			box = $box.get(0);
		} else
		// { $box: "selector" }
		if ( f.isString(params.$box) ) {
			$box = $(params.$box);
			box = $box.get(0);
		} else
		// { box: jQueryObject }
		if ( params.box instanceof $ ) {
			$box = params.box;
			box = $box.get(0);
		} else
		// { $box: jQueryObject }
		if ( params.$box instanceof $ ) {
			$box = params.$box;
			box = $box.get(0);
		} else
		// { $box: Element or str }
		if ( params.$box ) {
			$box = $(params.$box);
			box = $box.get(0);
		} else
		// { box: Element or str }
		if ( params.box ) {
			$box = $(params.box);
			box = $box.get(0);
		}

		if ( !(box instanceof Element) ) {
			throw new Error("Box is not are DOMElement");
		}

		this.box = box;
		this.$box = $box;
	};

    // достаем координаты из события mobile/desktop
    f.getMousePoint = function(e) {
        return f.getTouchPoint(e);
    };

    f.getTouchPoint = function(e) {
        if ( e.originalEvent && e.originalEvent.touches && e.originalEvent.touches.length > 0 ) {
            return {
                x: e.originalEvent.touches[0].pageX,
                y: e.originalEvent.touches[0].pageY
            };
        } else {
            return {
                x: e.pageX,
                y: e.pageY
            };
        }
    };
	
    f.downloadFile = function(sUrl) {
     
        //Creating new link node.
        var link = document.createElement('a');
        link.href = sUrl;
        
        if (link.download !== undefined){
            //Set HTML5 download attribute. This will prevent file from opening if supported.
            var fileName = sUrl.substring(sUrl.lastIndexOf('/') + 1, sUrl.length);
            link.download = fileName;
        }
    
        //Dispatching click event.
        if (document.createEvent) {
            var e = document.createEvent('MouseEvents');
            if ( f.aboutBrow().brow == "Internet Explorer" ) {
                link.target = "_blank";
                document.body.appendChild(link);
                e.initEvent('click' ,true ,true);
                link.dispatchEvent(e);
                link.outerHTML = "";
            } else {
                e.initEvent('click' ,true ,true);
                link.dispatchEvent(e);
            }
            
            return true;
        } else {
            window.open(sUrl, "_blank");
        }
    };

})();

;(function() {
    "use strict";
    
    function Events() {}
    
    Events.prototype = {
        on: function(events, handler, once) {
            if ( !this._events ) {this._events={};}

            if (!(events+='') || typeof handler !== 'function')
                return this;

            var name = '', event;
            events = events.split(/\s+/);
            for (var i=0, n= events.length; i<n; i++) {
                name = events[i];
                if (!(name+=''))
                    continue;

                event = this._events[name] || [];

                event.push({
                    once : !!once,
                    callback : handler
                });
                this._events[name] = event;
            }

            return this;
        },
        
        once: function(events, handler) {
            return this.on(events, handler, true);
        },
        
        off: function(events, handler) {
            if ( !this._events ) {this._events={};}

            if (!(events+=''))
                return this;

            var name = '',
                event,
                isFunc = typeof handler === 'function',
                toSave;

            events = events.split(/\s+/);

            for (var i=0, n= events.length; i<n; i++) {
                name = events[i];
                if (!name)
                    continue;

                event = this._events[name] || [];
                if ( !isFunc ) {
                    toSave = [];
                } else {
                    toSave = [];
                    for (var j=0, m=event.length; j<m; j++) {
                        if (event[j].callback === handler)
                            continue;

                        toSave.push(event[j]);
                    }
                    event = toSave;
                }
                if ( toSave.length ) {
                    this._events[name] = toSave;
                } else {
                    delete this._events[name];
                }
            }

            return this;
        },
        
        trigger: function(events) {
            if ( !this._events ) {this._events={};}

            if (typeof events != 'string')
                return this;

            var name = '',
                event,
                saves = [],
                result,
                args = [].slice.call(arguments, 1);

            events = events.split(/\s+/);

            for (var i=0, n = events.length; i<n; i++) {
                name = events[i];
                if ( name === '' ) {
                    continue;
                }

                if ( name != '*' ) {
                    callStack(this, '*', [name].concat(args));
                }
                callStack(this, name, args);
            }

            return this;
        },
        
        triggerAll: function() {
            for (var name in this._events) {
                if ( name == '*' ) {
                    continue;
                }
                callStack(this, name, arguments);
            }
            return this;
        },
        
        clearEvents: function() {
            this._events = {};
            if ( this._eventsListeners ) {
                this._eventsListeners.forEach(function(listener) {
                    listener.obj.off(listener.event, listener.handler);
                });
            }
            this._eventsListeners = [];
            return this;
        },
        
        listenTo: function(listenObj, events, handler) {
            if ( !this._eventsListeners ) {this._eventsListeners=[];}
            
            if ( events == 'all' ) {
                events = 'all *';
            }

            var context = this;

            if ( typeof handler != 'function' ) {
                handler = function(){};
            }
            
            var listener = {
                obj: listenObj,
                event: events,
                handler: handler.bind(context)
            };
            listenObj.on(events, listener.handler);
            this._eventsListeners.push(listener);
        },

        stopListening: function(obj, event) {
            if ( !this._eventsListeners ) {this._eventsListeners=[];}
            
            if ( f.isString(obj) ) {
                event = obj;
                obj = false;
            }
            
            this._eventsListeners.forEach(function(listener) {
                if ( !obj ) {
                    listener.obj.off(event, listener.handler);
                } else
                if ( listener.obj == obj ) {
                    listener.obj.off(event, listener.handler);
                }
            });
        }
    };
	
	function callStack(context, name, args) {
		var newStack = [],
			data,
			stack = context._events[name],
			result;

		if ( !stack ) {
			return;
		}

		for (var i=0, n=stack.length; i<n; i++) {
			data = stack[i];

			if ( typeof data.callback != 'function' ) {
				continue;
			}

			if ( !data.once ) {
				newStack.push(data);
			}

			result = data.callback.apply(context, args);
			if ( result === false ) {
				break;
			}
		}

		if ( newStack.length ) {
			context._events[name] = newStack;
		} else {
			delete context._events[name];
		}
	}
	
	f.Events = Events;
})();

;(function() {
    "use strict";

    // обычный объект превращаем в полские данные
    // где ключом будет нечто вроде:  "a[]"
    f.json2formDataArr = function(data, keyPrefix) {

        function value2arr(value, keyPrefix) {
            if ( !keyPrefix ) {
                keyPrefix = "";
            }

            var out = [];

            if ( f.isFileList(value) ) {
                for(var i=0, val, n=value.length; i<n; i++) {
                    val = value[i];
                    out = out.concat(value2arr(val, keyPrefix + '[]'));
                }
            } else

            if ( f.isArray(value) ) {
                for(var i=0, val, n=value.length; i<n; i++) {
                    val = value[i];
                    out = out.concat(value2arr(val, keyPrefix + '[]'));
                }
            } else
            if ( f.isObject(value) ) {
                out = out.concat(f.json2formDataArr(value, keyPrefix));
            } else {
                out.push({
                    key: keyPrefix,
                    value: value
                })
            }

            return out;
        }

        if (!keyPrefix) {
            keyPrefix = "";
        }

        var out = [];
        for (var key in data) {
            if ( keyPrefix ) {
                out = out.concat(value2arr(data[key], keyPrefix + '[' + key + ']' ));
            } else {
                out = out.concat(value2arr(data[key], key ));
            }
        }

        return out;
    };

    // превращаем объект в queryString
    function http_build_query(formdata, arg_separator) {

      var value, key, tmp = [],
        that = this;

      var _http_build_query_helper = function(key, val, arg_separator) {
        var k, tmp = [];
        if (val === true) {
          val = '1';
        } else if (val === false) {
          val = '0';
        }
        if (val != null) {
          if (typeof val === 'object') {
            for (k in val) {
              if (val[k] != null) {
                tmp.push(_http_build_query_helper(key + '[' + k + ']', val[k], arg_separator));
              }
            }
            return tmp.join(arg_separator);
          } else if (typeof val !== 'function') {
            return encodeURIComponent(key) + '=' + encodeURIComponent(val);
          } else {
            throw new Error('There was an error processing for http_build_query().');
          }
        } else {
          return '';
        }
      };

      if (!arg_separator) {
        arg_separator = '&';
      }
      for (key in formdata) {
        value = formdata[key];
        var query = _http_build_query_helper(key, value, arg_separator);
        if (query !== '') {
          tmp.push(query);
        }
      }

      return tmp.join(arg_separator);
    }
    window.http_build_query = f.http_build_query = http_build_query;

})();

;(function() {
    "use strict";
    
    // http://ejohn.org/blog/objectgetprototypeof/
    // определение прототипа объекта
    if ( typeof Object.getPrototypeOf !== "function" ) {
      if ( typeof "test".__proto__ === "object" ) {
        Object.getPrototypeOf = function(object){
          return object.__proto__;
        };
      } else {
        Object.getPrototypeOf = function(object){
          // May break if the constructor has been tampered with
          return object.constructor.prototype;
        };
      }
    }

})();

;(function() {
    "use strict";

    // набо функция для проверок на что-либо

    f.classOf = function(a) {
        return Object.prototype.toString.call( a ).slice(8, -1);
    };

    f.isFileList = function(a) {
        return f.classOf(a) == 'FileList' || f.isArray(a) && a.every(function(x) {
            return f.classOf(x) == 'File';
        });
    };

    f.isFunction = function( a ) {
        return typeof a === 'function';
    };

    f.isArray = function( a ) {
        // так быстрее, чем classof
        return a instanceof Array;
    };

    f.isObject = function( a ) {
        return a && typeof a === "object" && !(a instanceof Array);
    };

    f.isObjOrArr = function(a) {
        return f.isObject(a) || f.isArray(a);
    };

    f.isString = function( a ) {
        return typeof a == 'string';
    };

    f.isNumber = function( a ) {
        return typeof a == 'number' && +a === a;
    };

    f.isFile = function(a) {
        return a instanceof window.File || a instanceof window.Blob;
    };

    // проверяем является ли объект непосредственным наследником Object.prototype
    f.isEasyObject = function(obj) {
        return f.isObject(obj) && obj.constructor.prototype === Object.prototype
    };

    // проверка на массив, в котором все элементы это функции
    f.isArrayWithFuncs = function(arr) {
        if ( !f.isArray(arr) ) {
            return false;
        }

        for (var i=0, n=arr.length; i<n; i++) {
            if ( !f.isFunction(arr[i]) ) {
                return false;
            }
        }

        return true;
    };

    // проверяем что ev, это DOM событие
    f.isEvent = function(ev) {
        var out = false;
        if ( typeof jQuery != 'undefined' || typeof Events != 'undefined' ) {

            if ( typeof jQuery != 'undefined' ) {
                out = out || ev instanceof jQuery.Event;
            }

            if ( typeof Events != 'undefined' ) {
                out = out || ev instanceof Events;
            }
        }
        return out;
    };

    f.isNaN = function(a) {
        return typeof a == 'number' && +a !== a;
    };

    f.isPrimitive = function(a) {
        return typeof a !== 'object' && a !== null;
    };

    f.isDate = function(a) {
        return f.classOf(a) == "Date";
    };

    // проверяем, что 'a' это объект вида {start: number, end: number}
    f.isDateDistance = function(a) {
        return f.isObject(a) && f.isNumber(a.start) && f.isNumber(a.end);
    };

    f.isBoolean = function(a) {
        return typeof a === "boolean";
    };
    
    f.isArrayOfArrays = function(arr) {
        if ( !f.isArray(arr) ) {
            return false;
        }
        
        if ( arr.length === 0 ) {
            return false;
        }
        
        return arr.every(function(elem) {
            return f.isArray(elem);
        });
    };

})();

;(function() {
    "use strict";

    // "глубокое" смешивание
    f.deepMixin = function() {
        var obj = {},
            objs = [];

        [].forEach.call(arguments, function(obj) {
            if ( f.isObject(obj) ) {
                objs.push(obj);
            }
        });

        function mixin(a, b) {
            var value;

            for (var key in b) {
                value = b[key];

                if ( f.isEasyObject(value) ) {
                    if ( !f.isObject(a[key]) ) {
                        a[key] = {};
                    }
                    mixin(a[key], value);
                } else
                if ( f.isArray(value) ) {
                    a[key] = [];
                    value.forEach(function(elem) {
                        a[key].push( f.deepClone({x:elem}).x );
                    });
                } else {
                    a[key] = value;
                }
            }

            return a;
        }

        objs.forEach(function(copyObj) {
            mixin(obj, copyObj);
        });

        return obj;
    };

    // замиксовать только уникальные значения из объектов
    f.mixinUnique = function(source) {
		var objs = [].slice.call(arguments, 1);
		var allObjs = objs.concat([source]);
		if ( objs.length < 2 ) {
			return source;
		}

		var obj, others;
		for (var i=0, n=objs.length; i<n; i++) {
			obj = objs[i];
			others = allObjs.slice();
			others.splice(i, 1);

			for (var key in obj) {
				if ( f.objIndexOfByKey(others, key) == -1 ) {
					source[key] = obj[key];
				}
			}
		}

		return source;
	};
    
    f.toUpperFields = function(row) {
        var value;

        for (var key in row) {
            value = row[key];
            delete row[key];
            key = key.toUpperCase();
            row[key] = value;
        }
        
        return row;
    };
})();

;(function() {
    "use strict";

    // здесь будут расширения для String
    
	f.likeStr = function(str, search) {
		return str.toLowerCase().indexOf(search) != -1;
	};
    
    // первая буква в верхнем регистре + trim
    f.upFirstLetter = function(str) {
        str = str || "";// undefined, null => ""
        
        if ( !f.isString(str) ) {// custom objects and another
            str += "";
        }
        
        str = str.trim();
		/// (str[0] || "" ) пустая строка
        return (str[0] || "" ).toUpperCase() + str.slice(1);
    };
    
    // почти как f.currencySpaces,
    // только без округления
    f.addSpaces = function(str) {
        str = str.replace(/ /g, "");

        var hasPoint = str.indexOf(".") != -1; // "10."
        var afterPoint = str.split(".")[1] || "";
        str = str.split(".")[0];

        var symbols = str.split(""), symb;
        var out = [];
        var minus = symbols[0] == "-" ? "-" : "";

        if (minus) {
            symbols.splice(0, 1);
        }
        var n = symbols.length, x;

        if (n > 3) {
            for (var i = n - 1; i >= 0; i--) {
                symb = symbols[i];
                x = n - i - 1;

                if (x % 3 === 0 && x) {
                    out.push(" ");
                }

                out.push(symb);
            }
        } else {
            out = symbols.reverse();
        }


        out = minus + out.reverse().join("");

        if (hasPoint) {
            out += ".";
        }
        if (afterPoint) {
            afterPoint += "";
            out += afterPoint;
        }

        return out;
    };
    
    // 1 участник, 2 участника, 5 участников
    f.number2postfixIndex = function(numb) {
        if ( !numb ) { // 0
            return 5;
        }
        
        var postfixIndex = 5;
        if ( 
            /^[^1]?1$/.test(numb)
        ) {
            postfixIndex = 1;
        } else
        if ( 
            /^[^1]?[234]$/.test(numb)
        ) {
            postfixIndex = 2;
        }
        
        return postfixIndex;
    };
    
})();

;(function() {
    "use strict";
    
    f.htmlCodes = [
		{"name":"&nbsp;","code":"&#160;","value":" "},
		{"name":"&pound;","code":"&#163;","value":"£"},
		{"name":"&euro;","code":"&#8364;","value":"€"},
		{"name":"&para;","code":"&#182;","value":"¶"},
		{"name":"&sect;","code":"&#167;","value":"§"},
		{"name":"&copy;","code":"&#169;","value":"©"},
		{"name":"&reg;","code":"&#174;","value":"®"},
		{"name":"&trade;","code":"&#8482;","value":"™"},
		{"name":"&deg;","code":"&#176;","value":"°"},
		{"name":"&plusmn;","code":"&#177;","value":"±"},
		{"name":"&frac14;","code":"&#188;","value":"¼"},
		{"name":"&frac12;","code":"&#189;","value":"½"},
		{"name":"&frac34;","code":"&#190;","value":"¾"},
		{"name":"&times;","code":"&#215;","value":"×"},
		{"name":"&divide;","code":"&#247;","value":"÷"},
		{"name":"&fnof;","code":"&#402;","value":"ƒ"},
		{"name":"&Alpha;","code":"&#913;","value":"Α"},
		{"name":"&Beta;","code":"&#914;","value":"Β"},
		{"name":"&Gamma;","code":"&#915;","value":"Γ"},
		{"name":"&Delta;","code":"&#916;","value":"Δ"},
		{"name":"&Epsilon;","code":"&#917;","value":"Ε"},
		{"name":"&Zeta;","code":"&#918;","value":"Ζ"},
		{"name":"&Eta;","code":"&#919;","value":"Η"},
		{"name":"&Theta;","code":"&#920;","value":"Θ"},
		{"name":"&Iota;","code":"&#921;","value":"Ι"},
		{"name":"&Kappa;","code":"&#922;","value":"Κ"},
		{"name":"&Lambda;","code":"&#923;","value":"Λ"},
		{"name":"&Mu;","code":"&#924;","value":"Μ"},
		{"name":"&Nu;","code":"&#925;","value":"Ν"},
		{"name":"&Xi;","code":"&#926;","value":"Ξ"},
		{"name":"&Omicron;","code":"&#927;","value":"Ο"},
		{"name":"&Pi;","code":"&#928;","value":"Π"},
		{"name":"&Rho;","code":"&#929;","value":"Ρ"},
		{"name":"&Sigma;","code":"&#931;","value":"Σ"},
		{"name":"&Tau;","code":"&#932;","value":"Τ"},
		{"name":"&Upsilon;","code":"&#933;","value":"Υ"},
		{"name":"&Phi;","code":"&#934;","value":"Φ"},
		{"name":"&Chi;","code":"&#935;","value":"Χ"},
		{"name":"&Psi;","code":"&#936;","value":"Ψ"},
		{"name":"&Omega;","code":"&#937;","value":"Ω"},
		{"name":"&alpha;","code":"&#945;","value":"α"},
		{"name":"&beta;","code":"&#946;","value":"β"},
		{"name":"&gamma;","code":"&#947;","value":"γ"},
		{"name":"&delta;","code":"&#948;","value":"δ"},
		{"name":"&epsilon;","code":"&#949;","value":"ε"},
		{"name":"&zeta;","code":"&#950;","value":"ζ"},
		{"name":"&eta;","code":"&#951;","value":"η"},
		{"name":"&theta;","code":"&#952;","value":"θ"},
		{"name":"&iota;","code":"&#953;","value":"ι"},
		{"name":"&kappa;","code":"&#954;","value":"κ"},
		{"name":"&lambda;","code":"&#955;","value":"λ"},
		{"name":"&mu;","code":"&#956;","value":"μ"},
		{"name":"&nu;","code":"&#957;","value":"ν"},
		{"name":"&xi;","code":"&#958;","value":"ξ"},
		{"name":"&omicron;","code":"&#959;","value":"ο"},
		{"name":"&pi;","code":"&#960;","value":"π"},
		{"name":"&rho;","code":"&#961;","value":"ρ"},
		{"name":"&sigmaf;","code":"&#962;","value":"ς"},
		{"name":"&sigma;","code":"&#963;","value":"σ"},
		{"name":"&tau;","code":"&#964;","value":"τ"},
		{"name":"&upsilon;","code":"&#965;","value":"υ"},
		{"name":"&phi;","code":"&#966;","value":"φ"},
		{"name":"&chi;","code":"&#967;","value":"χ"},
		{"name":"&psi;","code":"&#968;","value":"ψ"},
		{"name":"&omega;","code":"&#969;","value":"ω"},
		{"name":"&larr;","code":"&#8592;","value":"←"},
		{"name":"&uarr;","code":"&#8593;","value":"↑"},
		{"name":"&rarr;","code":"&#8594;","value":"→"},
		{"name":"&darr;","code":"&#8595;","value":"↓"},
		{"name":"&harr;","code":"&#8596;","value":"↔"},
		{"name":"&spades;","code":"&#9824;","value":"♠"},
		{"name":"&clubs;","code":"&#9827;","value":"♣"},
		{"name":"&hearts;","code":"&#9829;","value":"♥"},
		{"name":"&diams;","code":"&#9830;","value":"♦"},
		{"name":"&quot;","code":"&#34;","value":"\""},
		{"name":"&amp;","code":"&#38;","value":"&"},
		{"name":"&lt;","code":"&#60;","value":"<"},
		{"name":"&gt;","code":"&#62;","value":">"},
		{"name":"&hellip;","code":"&#8230;","value":"…"},
		{"name":"&prime;","code":"&#8242;","value":"′"},
		{"name":"&Prime;","code":"&#8243;","value":"″"},
		{"name":"&ndash;","code":"&#8211;","value":"–"},
		{"name":"&mdash;","code":"&#8212;","value":"—"},
		{"name":"&lsquo;","code":"&#8216;","value":"‘"},
		{"name":"&rsquo;","code":"&#8217;","value":"’"},
		{"name":"&sbquo;","code":"&#8218;","value":"‚"},
		{"name":"&ldquo;","code":"&#8220;","value":"“"},
		{"name":"&rdquo;","code":"&#8221;","value":"”"},
		{"name":"&bdquo;","code":"&#8222;","value":"„"},
		{"name":"&laquo;","code":"&#171;","value":"«"},
		{"name":"&raquo;","code":"&#187;","value":"»"}
	];

	f.htmlCodesByCode = {};
	f.htmlCodesByName = {};

	for (var i=0, n=f.htmlCodes.length; i<n; i++) {
		f.htmlCodesByCode[f.htmlCodes[i].code] = f.htmlCodes[i];
		f.htmlCodesByName[f.htmlCodes[i].name] = f.htmlCodes[i];
	}

	f.getHtmlCodeValue = function(code) {
		return f.htmlCodesByName[code] || f.htmlCodesByCode[code];
	};

	f.stripTags = function(html) {
		if ( !f.isString(html) ) {
			return "";
		}

		return html
				.replace(/<br[^>]*>/gi, "\n")
				.replace(/<[^>]*>/g, "")
				.replace(/&#?\w+;/g, function(code) {
					code = f.getHtmlCodeValue(code);
					if ( code ) {
						return code.value;
					} else {
						return arguments[0];
					}
				})
		;
	};

})();

;(function() {
    "use strict";
    

	// создаем двунаправленное дерево строк,
	// где есть точка входа на любую строку.
	// каждый элемент будет в виде
	// {
	// 	row: object
	// 	children: object с элементами, где в качестве ключа id строки
	// 	parent: el - если родителя нет, то ("parent" in el) === false
	// }
	//
	//
	// example::
	/*
	 var rows = [
  	   {id: 1},
	   {id: 2, parent: 1},
	   {id: 3, parent: 1},
	   {id: 4, parent: 3},
	   {id: 5, parent: 3},
	   {id: 6, parent: 5},
	   {id: 7},
	   {id: 8, parent: 7},
	   {id: 9, parent: 7},
	   {id: 10}
	 ];

	 var tree = f.createTree(rows, "id", "parent");
	 tree;
	*/
	f.createTree = function(rows, idField, parentField) {
        var tree = {}, row, el, parent, id, parentId;
        for (var i = 0; i < rows.length; i++) {
            row = rows[i];
			id = row[idField];
			parentId = row[parentField];

			// создаем родительский элемент в корне,
			// потомок может встретиться раньше своего родителя
			parent = tree[parentId];
            if ( !parent ) {
				parent = {children: {}};
                tree[parentId] = parent;
            }

			// создаем элемент в корне
			el = tree[id];
			if ( !el ) {
				el = {children: {}};
				tree[id] = el;
			}
			el.row = row;

			if ( parentId ) {// отсекаем null, 0 в качестве id не встречается
				el.parent = parent;
			}

			parent.children[id] = el;
        }

		return tree;
    };
    
    // проходимся по элементам дерева, и находим те ветки, 
    // которые находятся в "лимбо" id родителя известен, 
    // но самого родителя нету
    /*
    var rows = [
      {id: 1},
      {id: 2, parent: 11},
      {id: 3, parent: 12},
      {id: 4, parent: 3},
      {id: 5, parent: 3},
      {id: 6, parent: 5},
      {id: 7},
      {id: 8, parent: 7},
      {id: 9, parent: 7},
      {id: 10}
    ];
   
    var tree = f.createTree(rows, "id", "parent");
    f.normolizeTree(tree, "id", tree["undefined"]);
    tree;
     */
    f.normolizeTree = function(tree, idField, root) {
        if ( !root || !root.children ) {
            return;
        }
        
        var elem;
        for (var id in tree) {
            elem = tree[id];
            
            if ( elem.row && elem.parent && !elem.parent.row ) {
                elem.parent = root;
                root.children[ elem.row[idField] ] = elem;
            }
        }
    };
    
	// вторая, более удобная версия построения дерева
	// первую версию не стал изменять, т.к. боюсь баги полезут
	// к тому же этот вариант немного медленей
	// 
	// создание дерева на 1 000 000 строк
	// f.createTree  ~1500 - 2000 ms
	// f.tree        ~2800 - 4000 ms
	// 
	// создание 5000 деревьев на 100 строк
	// f.createTree  ~500 - 1500 ms
	// f.tree        ~700 - 2000 ms
	f.tree = function(rows, idField, parentField) {
		var tree = new Tree(idField, parentField);
		
        for (var i = 0, n = rows.length; i < n; i++) {
            tree.add(rows[i]);
        }

		return tree;
	};
	
    var Tree = function(idField, parentField) {
        this.idField = idField;
        this.parentField = parentField;
        this.all = {};
        this.root = {
            byId: {},
            elems: []
        };
    };
    
    Tree.prototype.add = function(row) {
        var el, parent, id, parentId, tree = this,
            idField = this.idField,
            parentField = this.parentField;
		
		id = row[idField];
		parentId = row[parentField];

		// создаем родительский элемент в общем списке,
		// потомок может встретиться раньше своего родителя
		parent = tree.all[parentId];
        if ( !parent ) {
			parent = new TreeElem(parentId);
        }
		
		// создаем элемент в общем списке
		el = tree.all[id];
		if ( !el ) {
			el = new TreeElem(id);
			tree.all[id] = el;
		}
		el.row = row;
        el.tree = tree;
        
		if ( parentId ) {// отсекаем null
			el.parent = parent;
            tree.all[parentId] = parent;
		} else {
			// создаем элемент в корне
			// отсекаем дубли по id
			if ( !tree.root.byId[id] ) {
				tree.root.elems.push(el);
				tree.root.byId[id] = el;
			}
		}
		
		// отсекаем дубли по id
		if ( !parent.children.byId[id] ) {
			parent.children.byId[id] = el;
			parent.children.elems.push(el);
		}
    };
    
    Tree.prototype.removeBranch = function(id) {
        var elem = this.all[id];
        if ( !elem ) {
            return;
        }
        
        // удаляем со всеми потомками
        var children = [elem].concat(elem.children.getAll()),
            index;
        
        for (var i=0, n=children.length; i<n; i++) {
            elem = children[i];
            delete this.all[elem.id];
            
            // удаляем из корня, если элемент там есть
            delete this.root.byId[elem.id];
            index = this.root.elems.indexOf(elem);
            if ( index != -1 ) {
                this.root.elems.splice(index, 1);
            }
        }
    };
    
    Tree.prototype.clone = function() {
        var clone = new Tree(this.idField, this.parentField);
        for (var id in this.all) {
            clone.add(f.deepClone( this.all[id].row ));
        }
        return clone;
    };
    
    Tree.prototype.clear = function() {
        this.all = {};
        this.root = {
            byId: {},
            elems: []
        };
    };
    
    // ветки, которые ссылаются на несуществующий элемент попадают в корень
    Tree.prototype.normolize = function() {
        var elem, child;
        for (var id in this.all) {
            elem = this.all[id];
            
            if ( elem.id in this.root.byId ) {
                continue;
            }
            
            if ( !elem.row ) {
                delete this.all[ elem.id ];
                for (var i=0, n=elem.children.elems.length; i<n; i++) {
                    child = elem.children.elems[i];
                    this.root.elems.push(child);
                    this.root.byId[ child.id ] = child;
                }
            }
        }
    };
    
	var TreeElem = function TreeElem(id) {
		this.id = id;
		this.children = new TreeElemChildren();
	};
	
	TreeElem.prototype.getParents = function() {
		var parents = [],
			el = this;
		
		while ( el.parent ) {
			el = el.parent;
			parents.push(el);
		}

		return parents;
	};
	
	var TreeElemChildren = function TreeElemChildren() {
		this.byId = {};
		this.elems = [];
	};
	
	TreeElemChildren.prototype.getAll = function() {
		var elems = [],
			el,
			children = this;
		
		for (var i=0, n=children.elems.length; i<n; i++) {
			el = children.elems[i];
			elems.push(el);
			elems = elems.concat(el.children.getAll());
		}

		return elems;
	};
	

	// на основе f.createTree ищем все дочерние элементы
	f.getChildrenRows = function(tree) {
		var rows = [], el;

		for (var id in tree) {
			el = tree[id];
			rows.push(el.row);
			rows = rows.concat(f.getChildrenRows(el.children));
		}

		return rows;
	};

	// получаем строки всех родителей элемента
	f.getParentRows = function(el) {
		var parents = [];

		while ( el.parent ) {
			el = el.parent;
			parents.push(el.row);
		}

		return parents;
	};
	
	f.getRootElems = function(tree) {
		var elems = [], elem;
		for (var id in tree) {
			elem = tree[id];
			if ( !elem.parent && elem.row ) {
				elems.push(elem);
			}
		}
		return elems;
	};
	
    
	
})();
    return f;
})
})(
	typeof define == 'undefined' ? function(depends, callback) {
		if ( typeof module != 'undefined' ) {
            module.exports = callback();
        } else
		if ( typeof exports != "undefined" ) {
			eval("exports = {f}");
		} else {
            window.f = callback();
        }
	} : define,
	typeof window == 'undefined' ? {} : window
);
