;(function() {
    "use strict";
    

	// создаем двунаправленное дерево строк,
	// где есть точка входа на любую строку.
	// каждый элемент будет в виде
	// {
	// 	row: object
	// 	children: object с элементами, где в качестве ключа id строки
	// 	parent: el - если родителя нет, то ("parent" in el) === false
	// }
	//
	//
	// example::
	/*
	 var rows = [
  	   {id: 1},
	   {id: 2, parent: 1},
	   {id: 3, parent: 1},
	   {id: 4, parent: 3},
	   {id: 5, parent: 3},
	   {id: 6, parent: 5},
	   {id: 7},
	   {id: 8, parent: 7},
	   {id: 9, parent: 7},
	   {id: 10}
	 ];

	 var tree = f.createTree(rows, "id", "parent");
	 tree;
	*/
	f.createTree = function(rows, idField, parentField) {
        var tree = {}, row, el, parent, id, parentId;
        for (var i = 0; i < rows.length; i++) {
            row = rows[i];
			id = row[idField];
			parentId = row[parentField];

			// создаем родительский элемент в корне,
			// потомок может встретиться раньше своего родителя
			parent = tree[parentId];
            if ( !parent ) {
				parent = {children: {}};
                tree[parentId] = parent;
            }

			// создаем элемент в корне
			el = tree[id];
			if ( !el ) {
				el = {children: {}};
				tree[id] = el;
			}
			el.row = row;

			if ( parentId ) {// отсекаем null, 0 в качестве id не встречается
				el.parent = parent;
			}

			parent.children[id] = el;
        }

		return tree;
    };
    
    // проходимся по элементам дерева, и находим те ветки, 
    // которые находятся в "лимбо" id родителя известен, 
    // но самого родителя нету
    /*
    var rows = [
      {id: 1},
      {id: 2, parent: 11},
      {id: 3, parent: 12},
      {id: 4, parent: 3},
      {id: 5, parent: 3},
      {id: 6, parent: 5},
      {id: 7},
      {id: 8, parent: 7},
      {id: 9, parent: 7},
      {id: 10}
    ];
   
    var tree = f.createTree(rows, "id", "parent");
    f.normolizeTree(tree, "id", tree["undefined"]);
    tree;
     */
    f.normolizeTree = function(tree, idField, root) {
        if ( !root || !root.children ) {
            return;
        }
        
        var elem;
        for (var id in tree) {
            elem = tree[id];
            
            if ( elem.row && elem.parent && !elem.parent.row ) {
                elem.parent = root;
                root.children[ elem.row[idField] ] = elem;
            }
        }
    };
    
	// вторая, более удобная версия построения дерева
	// первую версию не стал изменять, т.к. боюсь баги полезут
	// к тому же этот вариант немного медленей
	// 
	// создание дерева на 1 000 000 строк
	// f.createTree  ~1500 - 2000 ms
	// f.tree        ~2800 - 4000 ms
	// 
	// создание 5000 деревьев на 100 строк
	// f.createTree  ~500 - 1500 ms
	// f.tree        ~700 - 2000 ms
	f.tree = function(rows, idField, parentField) {
		var tree = new Tree(idField, parentField);
		
        for (var i = 0, n = rows.length; i < n; i++) {
            tree.add(rows[i]);
        }

		return tree;
	};
	
    var Tree = function(idField, parentField) {
        this.idField = idField;
        this.parentField = parentField;
        this.all = {};
        this.root = {
            byId: {},
            elems: []
        };
    };
    
    Tree.prototype.add = function(row) {
        var el, parent, id, parentId, tree = this,
            idField = this.idField,
            parentField = this.parentField;
		
		id = row[idField];
		parentId = row[parentField];

		// создаем родительский элемент в общем списке,
		// потомок может встретиться раньше своего родителя
		parent = tree.all[parentId];
        if ( !parent ) {
			parent = new TreeElem(parentId);
        }
		
		// создаем элемент в общем списке
		el = tree.all[id];
		if ( !el ) {
			el = new TreeElem(id);
			tree.all[id] = el;
		}
		el.row = row;
        el.tree = tree;
        
		if ( parentId ) {// отсекаем null
			el.parent = parent;
            tree.all[parentId] = parent;
		} else {
			// создаем элемент в корне
			// отсекаем дубли по id
			if ( !tree.root.byId[id] ) {
				tree.root.elems.push(el);
				tree.root.byId[id] = el;
			}
		}
		
		// отсекаем дубли по id
		if ( !parent.children.byId[id] ) {
			parent.children.byId[id] = el;
			parent.children.elems.push(el);
		}
    };
    
    Tree.prototype.removeBranch = function(id) {
        var elem = this.all[id];
        if ( !elem ) {
            return;
        }
        
        // удаляем со всеми потомками
        var children = [elem].concat(elem.children.getAll()),
            index;
        
        for (var i=0, n=children.length; i<n; i++) {
            elem = children[i];
            delete this.all[elem.id];
            
            // удаляем из корня, если элемент там есть
            delete this.root.byId[elem.id];
            index = this.root.elems.indexOf(elem);
            if ( index != -1 ) {
                this.root.elems.splice(index, 1);
            }
        }
    };
    
    Tree.prototype.clone = function() {
        var clone = new Tree(this.idField, this.parentField);
        for (var id in this.all) {
            clone.add(f.deepClone( this.all[id].row ));
        }
        return clone;
    };
    
    Tree.prototype.clear = function() {
        this.all = {};
        this.root = {
            byId: {},
            elems: []
        };
    };
    
    // ветки, которые ссылаются на несуществующий элемент попадают в корень
    Tree.prototype.normolize = function() {
        var elem, child;
        for (var id in this.all) {
            elem = this.all[id];
            
            if ( elem.id in this.root.byId ) {
                continue;
            }
            
            if ( !elem.row ) {
                delete this.all[ elem.id ];
                for (var i=0, n=elem.children.elems.length; i<n; i++) {
                    child = elem.children.elems[i];
                    this.root.elems.push(child);
                    this.root.byId[ child.id ] = child;
                }
            }
        }
    };
    
	var TreeElem = function TreeElem(id) {
		this.id = id;
		this.children = new TreeElemChildren();
	};
	
	TreeElem.prototype.getParents = function() {
		var parents = [],
			el = this;
		
		while ( el.parent ) {
			el = el.parent;
			parents.push(el);
		}

		return parents;
	};
	
	var TreeElemChildren = function TreeElemChildren() {
		this.byId = {};
		this.elems = [];
	};
	
	TreeElemChildren.prototype.getAll = function() {
		var elems = [],
			el,
			children = this;
		
		for (var i=0, n=children.elems.length; i<n; i++) {
			el = children.elems[i];
			elems.push(el);
			elems = elems.concat(el.children.getAll());
		}

		return elems;
	};
	

	// на основе f.createTree ищем все дочерние элементы
	f.getChildrenRows = function(tree) {
		var rows = [], el;

		for (var id in tree) {
			el = tree[id];
			rows.push(el.row);
			rows = rows.concat(f.getChildrenRows(el.children));
		}

		return rows;
	};

	// получаем строки всех родителей элемента
	f.getParentRows = function(el) {
		var parents = [];

		while ( el.parent ) {
			el = el.parent;
			parents.push(el.row);
		}

		return parents;
	};
	
	f.getRootElems = function(tree) {
		var elems = [], elem;
		for (var id in tree) {
			elem = tree[id];
			if ( !elem.parent && elem.row ) {
				elems.push(elem);
			}
		}
		return elems;
	};
	
    
	
})();
