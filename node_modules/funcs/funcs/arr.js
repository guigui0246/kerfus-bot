;(function() {
    "use strict";
    // функции для работы с массивами
    
	//
	// !! \THROW/ WARNING !!
	// sorts: [{key: 1}, {KEY2: -1}]
	// default str sort
	f.multiSort = function(arr, sorts, comparatorByKey) {

		var keys = [], key;
		var vectors = {}, vector;

		sorts.forEach(function(row) {
			for (var key in row) {
				vector = row[key];

				if ( vector !== 1 && vector !== -1 ) {
					throw new Error("bad sort vector");
				}

				vectors[key] = vector;
				keys.push(key);
				break;
			}
		});

		//  сортировка по числу отличается от сортировки по строке
		var comparator_str = function(key, a, b) {
			return a[key] == b[key] ? 0 :
					a[key] > b[key] ? vectors[key] : -vectors[key];
		};

		var comparator_number = function(key, a, b) {
			return +a[key] == +b[key] ? 0 :
					+a[key] > +b[key] ? vectors[key] : -vectors[key];
		};

		var comparator_currency = function(key, a, b) {
			a = f.currencyToNumber(a[key]);
			b = f.currencyToNumber(b[key]);

			return +a == +b ? 0 :
					+a > +b ? vectors[key] : -vectors[key];
		};

		// пользовательские компораторы (сортировки по столбцу)
		if ( !comparatorByKey ) {
			comparatorByKey = {};
		} else {
			comparatorByKey = f.deepClone(comparatorByKey);
			for (key in comparatorByKey) {
				if ( f.isString(comparatorByKey[key]) ) {
					if ( comparatorByKey[key] == "number" ) {
						comparatorByKey[key] = comparator_number;
					} else
					if ( comparatorByKey[key] == "currency" ) {
						comparatorByKey[key] = comparator_currency;
					}
					if ( !f.isFunction(comparatorByKey[key]) ) {
						delete comparatorByKey[key];
					}
				}
			}
		}

		var n = keys.length;
		return arr.sort(function(a, b) {
			var res;
			for (var i=0; i<n; i++) {
				if ( comparatorByKey[keys[i]] ) {
					res = comparatorByKey[keys[i]](keys[i], a, b);
				} else {
					res = comparator_str(keys[i], a, b);
				}

				if ( res !== 0 ) {
					return res;
				}
			}
			return 0;
		});
	};
    
    f.multiSortModels = function(models, sorts, comparatorByKey) {
        // костыльно, зато эффективно
        var rows = models.map(function(model) {
            model.attributes.____model____ = model;
            return model.attributes;
        });
        
        rows = f.multiSort(rows, sorts, comparatorByKey);
        return rows.map(function(row) {
            var model = row.____model____;
            delete row.____model____;
            return model;
        });
    };

	// поиск индекса объекта, который содержит опередленный ключ
	f.objIndexOfByKey = function(objs, key) {
		for (var i=0, n=objs.length; i<n; i++) {
			if ( key in objs[i] ) {
				return i;
			}
		}
		return -1;
	};
    
    f.findObjects = function(source, check, path) {
        if ( !path ) {
            path = [];
        }
        var result = [];
        
        if ( f.isObject(source) ) {
            if ( check(source, path) ) {
                result.push(source);
            }
            for (var key in source) {
                result = result.concat( 
                        f.findObjects(
                            source[key], check, 
                            path.concat([["object", key, source]])
                        ) 
                    );
            }
        } else
        if ( f.isArray(source) ) {
            source.forEach(function(elem, i) {
                result = result.concat( 
                    f.findObjects(
                        elem, check,
                        path.concat([["array", i, source]])
                    ) 
                );
            });
        }
        
        return result;
    };
})();
