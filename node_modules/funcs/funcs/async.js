;(function() {
	"use strict";
	
	// полседовательное выполнение асинхронных функций
	// в голом виде не рекомендуется использовать
	f.series = function(series, callback, context) {
		if ( !f.isFunction(callback) ) {
			callback = function() {};
		}

		series = f.deepClone(series);
		var results = [];
		var resultErr = null;
        
        if ( !context ) {
            context = this;
        }
        
		function iterate() {
			var func = series.shift();
			func.call(context, function(err, result) {
				results.push(result);

				if ( err || series.length === 0 ) {
					return stop(err);
				}

				iterate();
			});
		}

		function stop(err) {
			if ( err ) {
				resultErr = err;
			}

			callback.call(context, resultErr, results);
		}
        
        if ( series.length === 0 ) {
            setTimeout(callback.bind(context, null, []), 0);
        } else {
            iterate();
        }
        
	};

	f.parallel = function(funcs, callback, context) {
		if ( !f.isFunction(callback) ) {
			callback = function() {};
		}
        
        if ( !context ) {
            context = this;
        }
        
		var results = [];
		var resultErr = null;
		var count = funcs.length;
		var stoped = false;
		function iterate(func) {
			if ( stoped ) {
				return;
			}

			func.call(context, function(err, result) {
				if ( stoped ) {
					return;
				}

				results.push(result);

				if ( err || results.length >= count ) {
					return stop(err);
				}
			});
		}

		function stop(err) {
			stoped = true;
			if ( err ) {
				resultErr = err;
			}

			callback.call(context, resultErr, results);
		}

		funcs.forEach(iterate);
		if ( funcs.length === 0 ) {
			stop();
		}
	};

    f.waitProp = function(obj, propName, callback) {
        var wait = function() {
            if ( obj[propName] ) {
                callback(obj);
            } else {
                // потеряет стек:
                // setTimeout(wait, 5);
                
                // не потеряет стек:
                setTimeout(function() {
                    wait();
                }, 5);
            }
        };
        
        wait();
    };
	//
    // без отличного понимания JS код не изменять !
    //
    // любой метод работает БЕЗ потери стека вызовов!
    var Queue = function(context) {
        this.context = context;
        this._loading = {
            inProcess: 0,
            total: 0
        };
        
        // ignore
        this._lastIgnoredCall = false;
        // rotation
        this._rotationCount = 0;
        this._rotationCurrent = 1;
        // series
        this._seriesStack = [];
    };
    
    // описание любого метода:
    // 
    // run - асинхронная функция, которая выполняется неопределенное кол-во времени.
    // она будет запущена, когда дождется своей очереди или будет запущена сразу, а может быть проигнорированна 
    // (зависит от метода)
    // 
    // callback - обратный вызов для run, который будет выполнен, только когда
    //   дождется своей очереди
    //   
    // важно понимать, что они между собой связаны!
    
    
    
    // series вызывает series, после завершения предыдущего вызова series
    //  
    //  r1_________c1 
    //                r2__c2 
    //                       r3___c3
    Queue.prototype.series = function(run, callback) {
        if ( this._destroyed ) {
            return;
        }
        if ( !f.isFunction(callback) ) {
            callback = function() {};
        }
        
        var context = this.context;
        
        this._seriesStack.push({
            run: run,
            callback: function() {
                var args = [].slice.call(arguments);
                callback.apply(context, args);
            }.bind(this)
        });
        
        this._seriesNext();
    };
    
    Queue.prototype._seriesNext = function() {
        if ( this._destroyed ) {
            return;
        }
        
        var context = this.context,
            call = this._seriesStack[0];
        
        if ( call && !call.loading ) {
            call.loading = true;
            
            call.run.call(context, function() {
                this._seriesStack.shift();
                
                var args = [].slice.call(arguments);
                call.callback.apply(context, args);
                
                this._seriesNext();
            }.bind(this));
        }
    };
    
    // rotation вызывает run сразу как вызван rotation,
    // callback будут вызваны по очереди (первый run, первый callback)
    //  
    //  r1_______c1
    //    r2__     c2
    //      r3___    c3
    //    
    Queue.prototype.rotation = function(run, callback) {
        if ( this._destroyed ) {
            return;
        }
        if ( !f.isFunction(callback) ) {
            callback = function() {};
        }
        
        var number = ++this._rotationCount,
            args = [],
            context = this.context;
        
        var wait = function() {
            if ( this._destroyed ) {
                return;
            }
            
            if ( this._rotationCurrent == number ) {
                callback.apply(context, args);
                this._rotationCurrent++;
                
                this._loading.total++;
                
                var nextCall = this._lastIgnoredCall;
                if ( nextCall ) {
                    this._lastIgnoredCall = null;
                    
                    this.ignore(
                        nextCall.run, 
                        nextCall.callback
                    );
                }
            } else {
                // потеряет стек:
                // setTimeout(wait, 5);
                
                // не потеряет стек:
                setTimeout(function() {
                    wait();
                }, 5);
            }
        }.bind(this);
        
        this._loading.inProcess++;
        run.call(context, function() {
            args = [].slice.call(arguments);
            wait();
        });
    };
    
    // принцип игнорирования вызовов, во время ожидания ответа
    //  
    //  r1_________c1 |
    //   ignore r2    |
    //    ignore r3   |
    //                 r3_________c3
    //                   ignore...
    Queue.prototype.ignore = function(run, callback) {
        if ( this._destroyed ) {
            return;
        }
        
        if ( !f.isFunction(callback) ) {
            callback = function() {};
        }
        
        var call = {run: run, callback: callback};
        
        if ( this._loading.total < this._loading.inProcess ) {
            this._lastIgnoredCall = call;
            return;
        }
        this._loading.inProcess++;
        
        var context = this.context;
        run.call(context, function() {
            if ( this._destroyed ) {
                return;
            }
            
            this._loading.total++;
            
            var args = [].slice.call(arguments);
            callback.apply(context, args);
            
            var nextCall = this._lastIgnoredCall;
            if ( nextCall ) {
                this._lastIgnoredCall = null;
                
                this.ignore(
                    nextCall.run, 
                    nextCall.callback
                );
            }
        }.bind(this));
    };
    
    Queue.prototype.destroy = function() {
        this._destroyed = true;
        this._seriesStack = [];
    };
    f.queue = function(context) {
    
        return new Queue(context);
    };
    
    
    // ну и пример использования
    // 
    // SERIES
    /*
    var self = {};
    var queue = f.queue(self);


    queue.series(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r1");
    }, function() {
        console.log("c1");
    });


    queue.series(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r2");
    }, function() {
        console.log("c2");
    });

    queue.series(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r3");
    }, function() {
        console.log("c3");
    });
    
    //  r1
    //  c1
    //  r2
    //  c2
    //  r3
    //  c3
    */
    // ROTATION
    /*
    var self = {};
    var queue = f.queue(self);
 
 
    queue.rotation(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r1");
    }, function() {
        console.log("c1");
    });
 
 
    queue.rotation(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r2");
    }, function() {
        console.log("c2");
    });
 
    queue.rotation(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r3");
    }, function() {
        console.log("c3");
    });
    
    //  r1
    //  r2
    //  r3
    //  c1
    //  c2
    //  c3
    */
    // IGNORE
    /*
    var self = {};
    var queue = f.queue(self);
 
 
    queue.ignore(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r1");
    }, function() {
        console.log("c1");
    });
 
 
    queue.ignore(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r2");
    }, function() {
        console.log("c2");
    });
 
    queue.ignore(function(callback) {
        setTimeout(callback, Math.random() * 10);
        console.log("r3");
    }, function() {
        console.log("c3");
    });
    
    //  r1
    //  c1
    //  r3
    //  c3
    */
    
   
})();
